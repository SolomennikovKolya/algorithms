
### Алгоритм быстрой сортировки (QuickSort)

1. Что делает
	- Сортирует массив по принципу "разделяй и властвуй", рекурсивно деля массив на подмассивы.

2. Сложность алгоритма
	- В среднем и лучшем случае: $O(n \log n)$, где $n$ — количество элементов в массиве.
	- В худшем случае: $O(n^2)$. Это происходит, если опорные элементы выбираются неудачно (например, если в отсортированном массиве, всегда выбирается крайний элемент).

3. Краткое описание принципа работы алгоритма
	1. Алгоритм выбирает опорный элемент (pivot), который помогает разделить массив.
	2. Затем массив разбивается на два подмассива:
		- Левый подмассив содержит элементы, меньшие или равные опорному.
		- Правый подмассив содержит элементы, большие опорного.
	3. Быстрая сортировка вызывается рекурсивно для каждого подмассива.
	4. В конце шагов массив становится отсортированным, так как каждый элемент оказывается на своем месте.

4. Улучшения алгоритма
	1. Выбор опорного элемента (pivot)
		- Медиана трёх: вместо выбора случайного или центрального элемента как опорного, взять медиану первых, средних и последних элементов. Это позволяет снизить вероятность неудачного разбиения, особенно для уже частично отсортированных массивов.
		- Случайный опорный элемент: случайный выбор опорного элемента уменьшает вероятность худшего случая, особенно на отсортированных или почти отсортированных данных.
	2. Рекурсивное ограничение (Переход на сортировку вставками)
		- При небольших размерах подмассивов (например, размером менее 10 элементов) переход на сортировку вставками может быть более эффективен. Сортировка вставками менее затратна для коротких массивов, так как работает быстрее на отсортированных или почти отсортированных данных.
	3. Трёхстороннее разбиение (Dutch National Flag Algorithm)
		- Вместо стандартного разбиения на два подмассива (меньше и больше опорного элемента), можно разбить массив на три части: меньшие, равные и большие опорному элементу. Это улучшение полезно для массивов с множеством одинаковых элементов, так как позволяет уменьшить число рекурсивных вызовов.
	4. Хвостовая рекурсия (Tail Recursion Optimization)
		- Использование хвостовой рекурсии снижает глубину стека вызовов, что уменьшает вероятность переполнения стека. Вместо рекурсивного вызова для обеих частей массива, можно использовать итеративный подход для одной из частей. Обычно сначала обрабатывают меньший подмассив рекурсивно, а затем продолжают с большим подмассивом в цикле.
